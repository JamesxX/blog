---
layout: post
title: "Column-major typst table definitions - a rabbit hole"
---

Anything worthy of being displayed in a table is more likely than not at least a 2D array, and frequently an array of dictionaries. It is probably stored as a csv file, but for the sake of brevity, let us assume that it is encoded in the source field already.

```typ
#table(
  columns: (auto,) + (1fr,)*4,
  align: center + horizon,
  
  // Header with hlines, ...
  // ... followed by body
   ($ H_v^"pc"times $),  ($ 1 $),
                          ($ (rho_"solvent")/(M_"solvent") $), 
                          ($ (rho_"solvent")/(M_"solute") $),     
                          ($ 1 / ( R T ) $),
    
    ($ H_v^"px"times $),  ($ (M_"solvent")/(rho_"solvent") $),
                          ($ 1 $),
                          ($ (M_"solvent")/(M_"solute") $), 
                          ($ (M_"solvent")/(R T rho_"solvent") $),
                          
    ($ H_v^"pw"times $),  ($ (M_"solute")/(rho_"solvent") $),
                          ($ (M_"solute")/(M_"solvent") $),
                          ($ 1 $), 
                          ( $ (M_"solute")/(R T rho_"solvent") $),
                          
    ($ H_v^"cc"times $),  ($ R T$),
                          ($ (R T rho_"solvent")/(M_"solvent") $),
                          ($ (R T rho_"solvent")/(M_"solute") $), 
                          ($ 1 $),
)
```

Suppose now you want to remove a row. You have to go through each and every positional argument and check that everything lines up where its meant to. You could check that the output is correct in the preview window, but for complicated maths like shown above, the task is no easier. All of this is without complicating factors like rowspans or colspans (*shudder*) and their associated hlines or vlines. All these problems arrise because we have to chose the order in which we enter information - by row or by column. In Typst, entry is done in row-major (that is, we must fill a row before starting the next). This is useful for cases where you want to remove a row, but removing a row is perhaps done more correctly by removing it from the dataset in the first place.

# Column-major definitions
Refusing to take the L on the problems listed above, I set out to create a function that would translate column-major into row-major. I also wanted to make an easy way of relating the column definitions to how the data is actually laid out. Lastly, I wanted per-column variables (fill, align, width, gutter) to be grouped together too. The design I came up with ended up looking like this:
```typ
#let example = (
  (
    key: "date",
    display: [Date],
    // fill: bg-fill-1,
    // align: left,
    width: 5em,
    gutter: 0.5em,
  ),
  (
    key: "particulars",
    display: text(tracking: 5pt)[Particulars],
    width: 1fr,
    gutter: 0.5em,
  ),
  (
    key: "ledger",
    display: [Ledger],
    // fill: bg-fill-2,
    width: 2cm,
    // align: center,
    gutter: 0.5em,
  ),
  (
    key: "amount", 
    display: align(center)[Amount],
    // fill: bg-fill-1,
    gutter: 0.5em,
    hline: arguments(stroke: booktabs.lightrule),
    children: (
      (
        key: "unit", 
        display: align(left)[£], 
        width: 5em, 
        align: right,
        vline: arguments(stroke: booktabs.lightrule),
        gutter: 0em,
      ),
      (
        key: "decimal",
        display: align(right, text(number-type: "old-style")[.00]), 
        width: 2em,
        // align: left
      ),
    )
  ),
  (
    key: "total", 
    display: align(center)[Total],
    gutter: 0.5em,
    hline: arguments(stroke: booktabs.lightrule),
    children: (
      (
        key: "unit", 
        display: align(left)[£], 
        width: 5em, 
        align: right,
        vline: arguments(stroke: booktabs.lightrule),
        gutter: 0em,
      ),
      (
        key: "decimal",
        display: align(right, text(number-type: "old-style")[.00]), 
        width: 2em,
        align: left
      ),
    )
  ),
)
```
