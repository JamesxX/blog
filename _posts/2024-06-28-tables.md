---
layout: post
title: "Column-major typst table definitions - a rabbit hole"
---
Foreword: This post pertains to Typst v0.11.1, and most likely won't be updated. So to future netizens: your mileage may vary. 

Anything worthy of being displayed in a table is more likely than not at least a 2D array, and frequently an array of dictionaries. It is probably stored as a csv file, but for the sake of brevity, let us assume that it is encoded in the source field already.

```typ
#table(
  columns: (auto,) + (1fr,)*4,
  align: center + horizon,
  
  // Header with hlines, ...
  // ... followed by body
   ($ H_v^"pc"times $),  ($ 1 $),
                          ($ (rho_"solvent")/(M_"solvent") $), 
                          ($ (rho_"solvent")/(M_"solute") $),     
                          ($ 1 / ( R T ) $),
    
    ($ H_v^"px"times $),  ($ (M_"solvent")/(rho_"solvent") $),
                          ($ 1 $),
                          ($ (M_"solvent")/(M_"solute") $), 
                          ($ (M_"solvent")/(R T rho_"solvent") $),
                          
    ($ H_v^"pw"times $),  ($ (M_"solute")/(rho_"solvent") $),
                          ($ (M_"solute")/(M_"solvent") $),
                          ($ 1 $), 
                          ( $ (M_"solute")/(R T rho_"solvent") $),
                          
    ($ H_v^"cc"times $),  ($ R T$),
                          ($ (R T rho_"solvent")/(M_"solvent") $),
                          ($ (R T rho_"solvent")/(M_"solute") $), 
                          ($ 1 $),
)
```

Suppose now you want to remove a row. You have to go through each and every positional argument and check that everything lines up where its meant to. You could check that the output is correct in the preview window, but for complicated maths like shown above, the task is no easier. All of this is without complicating factors like rowspans or colspans (*shudder*) and their associated hlines or vlines. All these problems arrise because we have to chose the order in which we enter information - by row or by column. In Typst, entry is done in row-major (that is, we must fill a row before starting the next). This is useful for cases where you want to remove a row, but removing a row is perhaps done more correctly by removing it from the dataset in the first place.

# Column-major definitions
Refusing to take the L on the problems listed above, I set out to create a function that would translate column-major into row-major. I also wanted to make an easy way of relating the column definitions to how the data is actually laid out. Because I don't want to make life any easier, I wanted nested columns (children) to be grouped with their parent. Lastly, I wanted per-column variables (fill, align, width, gutter) to be grouped together too, plus inheritence. The design I came up with ended up looking like this:
```typ
#let example = (
  (
    key: "date",
    display: [Date],
    // fill: bg-fill-1,
    // align: left,
    width: 5em,
    gutter: 0.5em,
  ),
  (
    key: "particulars",
    display: text(tracking: 5pt)[Particulars],
    width: 1fr,
    gutter: 0.5em,
  ),
  (
    key: "ledger",
    display: [Ledger],
    // fill: bg-fill-2,
    width: 2cm,
    // align: center,
    gutter: 0.5em,
  ),
  (
    key: "amount", 
    display: align(center)[Amount],
    // fill: bg-fill-1,
    gutter: 0.5em,
    hline: arguments(stroke: booktabs.lightrule),
    children: (
      (
        key: "unit", 
        display: align(left)[£], 
        width: 5em, 
        align: right,
        vline: arguments(stroke: booktabs.lightrule),
        gutter: 0em,
      ),
      (
        key: "decimal",
        display: align(right, text(number-type: "old-style")[.00]), 
        width: 2em,
        // align: left
      ),
    )
  ),
  (
    key: "total", 
    display: align(center)[Total],
    gutter: 0.5em,
    hline: arguments(stroke: booktabs.lightrule),
    children: (
      (
        key: "unit", 
        display: align(left)[£], 
        width: 5em, 
        align: right,
        vline: arguments(stroke: booktabs.lightrule),
        gutter: 0em,
      ),
      (
        key: "decimal",
        display: align(right, text(number-type: "old-style")[.00]), 
        width: 2em,
        align: left
      ),
    )
  ),
)
```

## Recursion
The first step towards implementing this is to deal with nested columns. There isn't a limit on how deep these nests can be (outside of hardware limitations), so this task (and most that follow) will be accomplished using recursion. Recursive functions are functions that end up calling themselves in some circumstances. In our case, we are going to go down each rabit hole, and record the depth of each column aswell as a recursive count of how many child elements it has. Finally, we will also want to know what the maximum depth is a bit later on, so we may aswell calculate that now.

```typ
#let sanitize-input(columns, depth: 0, max-depth: 1, length: 0) = {

  // For every column
  for (key, entry) in columns.enumerate() {

    // if it has children
    if "children" in entry {

      // Recurse
      let (children, child-depth, child-length) = sanitize-input(entry.children, depth: depth + 1, max-depth: max-depth + 1)

      // record the recursive length
      columns.at(key).insert("length", child-length)      
      columns.at(key).children = children
      length += child-length

      // Keep track of the deepest yet seen rabit hole
      max-depth = calc.max(max-depth, child-depth)

    // Bottom of the rabit hole, must have a length of 1
    } else {
      length += 1
      columns.at(key).insert("length", 1)
    }

    // In all cases, keep track of depth
    columns.at(key).insert("depth", depth)
  }

  // Pass the results on
  return (columns, max-depth, length)
}

```
As this function
